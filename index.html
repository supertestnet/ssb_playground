<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <title>Cleanup Crew</title>
        <script src="https://bundle.run/buffer@6.0.3"></script>
        <script>var Buffer = buffer.Buffer;</script>
        <script src="https://supertestnet.github.io/bitcoin-chess/js/bitcoinjs-lib.js"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <script>
            var cleanup_crew = {
                waiting: false,
                network: "regtest",
                in_progress: null,
                waitSomeTime: num => new Promise( resolve => setTimeout( resolve, num ) ),
                wait: async () => {
                    cleanup_crew.waiting = true;
                    var loop = async () => {
                        if ( !cleanup_crew.waiting ) return;
                        await cleanup_crew.waitSomeTime( 10 );
                        return await loop();
                    }
                    return await loop();
                },
                reverseHexString: s => s.match( /[a-fA-F0-9]{2}/g ).reverse().join( '' ),
                decodeCompactSize: compact_size => {
                    var reverseHexString = cleanup_crew.reverseHexString;
                    var first_byte = compact_size.substring( 0, 2 ).toLowerCase();
                    var size = Number( BigInt( `0x${reverseHexString( compact_size.substring( 0, 2 ) )}` ) );
                    var actual_compact_size = compact_size.substring( 0, 2 );
                    if ( first_byte === "fd" ) {
                        var rest = compact_size.substring( 2, 2 + 4 ).toLowerCase();
                        var size = Number( BigInt( `0x${reverseHexString( rest )}` ) );
                        var actual_compact_size = compact_size.substring( 0, 6 );
                    }
                    if ( first_byte === "fe" ) {
                        var rest = compact_size.substring( 2, 2 + 8 ).toLowerCase();
                        var size = Number( BigInt( `0x${reverseHexString( rest )}` ) );
                        var actual_compact_size = compact_size.substring( 0, 10 );
                    }
                    if ( first_byte === "ff" ) {
                        var rest = compact_size.substring( 2 ).toLowerCase();
                        var size = Number( BigInt( `0x${reverseHexString( rest )}` ) );
                        var actual_compact_size = compact_size;
                    }
                    return { size, first_byte, actual_compact_size }
                },
                parseTransactions: ( num_of_txs, txs ) => {
                    var decodeCompactSize = cleanup_crew.decodeCompactSize;
                    var rest = txs;
                    var tx_objects = [];
                    var loop = rest => {
                        var tx = {}
                        tx[ "hex" ] = ``;
                        tx[ "version" ] = rest.substring( 0, 8 );
                        tx[ "hex" ] += rest.substring( 0, 8 );
                        var rest = rest.substring( 8 );
                        var is_segwit = rest.substring( 0, 4 ) === "0001";
                        if ( is_segwit ) {
                            tx[ "segwit_flag" ] = rest.substring( 0, 4 );
                            tx[ "is_segwit" ] = true;
                            tx[ "hex" ] += rest.substring( 0, 4 );
                            rest = rest.substring( 4 );
                        }
                        var compact_size = rest.substring( 0, 18 );
                        var { size, first_byte, actual_compact_size } = decodeCompactSize( compact_size );
                        tx[ "number_of_inputs" ] = [ size , actual_compact_size ];
                        tx[ "hex" ] += rest.substring( 0, 2 );
                        rest = rest.substring( 2 );
                        if ( first_byte === "fd" ) tx[ "hex" ] += rest.substring( 0, 4 );
                        if ( first_byte === "fd" ) rest = rest.toString( "hex" ).substring( 4 );
                        if ( first_byte === "fe" ) tx[ "hex" ] += rest.substring( 0, 8 );
                        if ( first_byte === "fe" ) rest = rest.substring( 8 );
                        if ( first_byte === "ff" ) tx[ "hex" ] += rest.substring( 0, 16 );
                        if ( first_byte === "ff" ) rest = rest.substring( 16 );
                        var num_of_inputs = size;
                        var i; for ( i=0; i<num_of_inputs; i++ ) {
                            tx[ `input_${i}` ] = {txid: rest.substring( 0, 64 ), vout: rest.substring( 64, 64 + 8 )}
                            tx[ "hex" ] += rest.substring( 0, 64 + 8 );
                            rest = rest.substring( 64 + 8 );
                            var compact_size = rest.substring( 0, 18 );
                            var { size, first_byte, actual_compact_size } = decodeCompactSize( compact_size );
                            tx[ `input_${i}` ][ "length_of_scriptsig" ] = [ size, actual_compact_size ];
                            tx[ "hex" ] += rest.substring( 0, 2 );
                            rest = rest.substring( 2 );
                            if ( first_byte === "fd" ) tx[ "hex" ] += rest.substring( 0, 4 );
                            if ( first_byte === "fd" ) rest = rest.toString( "hex" ).substring( 4 );
                            if ( first_byte === "fe" ) tx[ "hex" ] += rest.substring( 0, 8 );
                            if ( first_byte === "fe" ) rest = rest.substring( 8 );
                            if ( first_byte === "ff" ) tx[ "hex" ] += rest.substring( 0, 16 );
                            if ( first_byte === "ff" ) rest = rest.substring( 16 );
                            tx[ `input_${i}` ][ "scriptsig" ] = rest.substring( 0, tx[ `input_${i}` ][ "length_of_scriptsig" ][ 0 ] * 2 );
                            tx[ "hex" ] += rest.substring( 0, tx[ `input_${i}` ][ "length_of_scriptsig" ][ 0 ] * 2 );
                            rest = rest.substring( tx[ `input_${i}` ][ "length_of_scriptsig" ][ 0 ] * 2 );
                            tx[ `input_${i}` ][ "sequence" ] = rest.substring( 0, 8 );
                            tx[ "hex" ] += rest.substring( 0, 8 );
                            rest = rest.substring( 8 );
                        }
                        var compact_size = rest.substring( 0, 18 );
                        var { size, first_byte, actual_compact_size } = decodeCompactSize( compact_size );
                        tx[ `num_of_outputs` ] = [ size, actual_compact_size ];
                        tx[ "hex" ] += rest.substring( 0, 2 );
                        rest = rest.substring( 2 );
                        if ( first_byte === "fd" ) tx[ "hex" ] += rest.substring( 0, 4 );
                        if ( first_byte === "fd" ) rest = rest.toString( "hex" ).substring( 4 );
                        if ( first_byte === "fe" ) tx[ "hex" ] += rest.substring( 0, 8 );
                        if ( first_byte === "fe" ) rest = rest.substring( 8 );
                        if ( first_byte === "ff" ) tx[ "hex" ] += rest.substring( 0, 16 );
                        if ( first_byte === "ff" ) rest = rest.substring( 16 );
                        var num_of_outputs = size;
                        var i; for ( i=0; i<num_of_outputs; i++ ) {
                            tx[ `output_${i}` ] = {value: rest.substring( 0, 16 )}
                            tx[ "hex" ] += rest.substring( 0, 16 );
                            rest = rest.substring( 16 );
                            var compact_size = rest.substring( 0, 18 );
                            var { size, first_byte, actual_compact_size } = decodeCompactSize( compact_size );
                            tx[ `output_${i}` ][ "length_of_scriptPubKey" ] = [ size, actual_compact_size ];
                            tx[ "hex" ] += rest.substring( 0, 2 );
                            rest = rest.substring( 2 );
                            if ( first_byte === "fd" ) tx[ "hex" ] += rest.substring( 0, 4 );
                            if ( first_byte === "fd" ) rest = rest.toString( "hex" ).substring( 4 );
                            if ( first_byte === "fe" ) tx[ "hex" ] += rest.substring( 0, 8 );
                            if ( first_byte === "fe" ) rest = rest.substring( 8 );
                            if ( first_byte === "ff" ) tx[ "hex" ] += rest.substring( 0, 16 );
                            if ( first_byte === "ff" ) rest = rest.substring( 16 );
                            tx[ `output_${i}` ][ "scriptPubKey" ] = scriptPubKey = rest.substring( 0, size * 2 );    
                            tx[ "hex" ] += rest.substring( 0, size * 2 );
                            rest = rest.substring( size * 2 );
                        }
                        if ( is_segwit ) {
                            var i; for ( i=0; i<num_of_inputs; i++ ) {
                                var compact_size = rest.substring( 0, 18 );
                                var { size, first_byte, actual_compact_size } = decodeCompactSize( compact_size );
                                tx[ `input_${i}` ][ "num_of_elements_in_witness" ] = [ size, actual_compact_size ];
                                tx[ `input_${i}` ][ "sizes_of_each_witness_element" ] = [];
                                tx[ `input_${i}` ][ "witness" ] = [];
                                tx[ "hex" ] += rest.substring( 0, 2 );
                                rest = rest.substring( 2 );
                                if ( first_byte === "fd" ) tx[ "hex" ] += rest.substring( 0, 4 );
                                if ( first_byte === "fd" ) rest = rest.toString( "hex" ).substring( 4 );
                                if ( first_byte === "fe" ) tx[ "hex" ] += rest.substring( 0, 8 );
                                if ( first_byte === "fe" ) rest = rest.substring( 8 );
                                if ( first_byte === "ff" ) tx[ "hex" ] += rest.substring( 0, 16 );
                                if ( first_byte === "ff" ) rest = rest.substring( 16 );
                                var num_of_elements = size;
                                var j; for ( j=0; j<num_of_elements; j++ ) {
                                    var compact_size = rest.substring( 0, 18 );
                                    var { size, first_byte, actual_compact_size } = decodeCompactSize( compact_size );
                                    tx[ `input_${i}` ][ "sizes_of_each_witness_element" ].push( [ size, actual_compact_size ] );
                                    tx[ "hex" ] += rest.substring( 0, 2 );
                                    rest = rest.substring( 2 );
                                    if ( first_byte === "fd" ) tx[ "hex" ] += rest.substring( 0, 4 );
                                    if ( first_byte === "fd" ) rest = rest.toString( "hex" ).substring( 4 );
                                    if ( first_byte === "fe" ) tx[ "hex" ] += rest.substring( 0, 8 );
                                    if ( first_byte === "fe" ) rest = rest.substring( 8 );
                                    if ( first_byte === "ff" ) tx[ "hex" ] += rest.substring( 0, 16 );
                                    if ( first_byte === "ff" ) rest = rest.substring( 16 );
                                    tx[ `input_${i}` ][ "witness" ].push( rest.substring( 0, size * 2 ) );
                                    tx[ "hex" ] += rest.substring( 0, size * 2 );
                                    rest = rest.substring( size * 2 );
                                }
                            }
                        }
                        tx[ `locktime` ] = rest.substring( 0, 8 );
                        tx[ "hex" ] += rest.substring( 0, 8 );
                        rest = rest.substring( 8 );
                        return [ tx, rest ];
                    }
                    var i; for ( i=0; i<num_of_txs; i++ ) {
                        var [ tx, rest ] = loop( rest );
                        tx_objects.push( tx );
                    }
                    return tx_objects;
                },
                getLegacySighash: ( txhex, prev_tx, input_num, sigflag, redeem_script ) => {
                    var parseTransactions = cleanup_crew.parseTransactions;
                    //Create a copy of the transaction (txCopy)
                    var original = parseTransactions( 1, txhex )[ 0 ];
                    var txcopy = parseTransactions( 1, txhex )[ 0 ];
                    //For all inputs in txCopy, set the scriptSig to empty (length 0)
                    var i; for ( i=0; i<txcopy.number_of_inputs[ 0 ]; i++ ) {
                        txcopy[ `input_${i}` ].scriptsig = "";
                        var length_of_scriptsig = txcopy[ `input_${i}` ].scriptsig.length / 2;
                        var length_of_scriptsig_hex = length_of_scriptsig.toString( 16 );
                        if ( length_of_scriptsig_hex.length % 2 ) length_of_scriptsig_hex = "0" + length_of_scriptsig_hex;
                        txcopy[ `input_${i}` ].length_of_scriptsig = [ length_of_scriptsig, length_of_scriptsig_hex ];
                    }
                    //Set the scriptSig of the current input to its scriptPubKey (or its redeemScript, if a p2sh output is being spent)
                    txcopy[ `input_${input_num}` ].scriptsig = bitcoinjs.Transaction.fromHex( prev_tx ).outs[ bitcoinjs.Transaction.fromHex( txhex ).ins[ input_num ].index ].script.toHex();
                    if ( redeem_script ) txcopy[ `input_${input_num}` ].scriptsig = redeem_script;
                    var length_of_scriptsig = txcopy[ `input_${input_num}` ].scriptsig.length / 2;
                    var length_of_scriptsig_hex = length_of_scriptsig.toString( 16 );
                    if ( length_of_scriptsig_hex.length % 2 ) length_of_scriptsig_hex = "0" + length_of_scriptsig_hex;
                    txcopy[ `input_${input_num}` ].length_of_scriptsig = [ length_of_scriptsig, length_of_scriptsig_hex ];

                    //TODO: Remove everything up to and including the last executed OP_CODESEPARATOR (or the entire script before the signature check if none executed)
                    //TODO: Remove all remaining OP_CODESEPARATOR opcodes
                    //TODO: Apply FindAndDelete: delete any occurrences of the current signature (exact byte match, excluding the sighash byte suffix) from the current scriptsig
                    //If the ANYONECANPAY flag is set, apply the following additional modifications
                    var anyone_can_pay_is_set = false;
                    if ( sigflag === "81" || sigflag === "82" || sigflag === "83" ) {
                        anyone_can_pay_is_set = true;
                        //--- Set the input vector to contain only the current input
                        var current_input = JSON.parse( JSON.stringify( txcopy[ `input_${input_num}` ] ) );
                        var i; for ( i=0; i<txcopy.number_of_inputs[ 0 ]; i++ ) delete txcopy[ `input_${i}` ];
                        txcopy[ `input_${input_num}` ] = current_input;
                        txcopy.number_of_inputs = [ 1, "01" ];
                    }
                    //If the SIGHASH_NONE flag is set, apply the following additional modifications
                    if ( sigflag === "02" || sigflag === "82" ) {
                        //--- Set the output vector to empty
                        var i; for ( i=0; i<txcopy.num_of_outputs[ 0 ]; i++ ) delete txcopy[ `output_${i}` ];
                        txcopy.num_of_outputs = [ 0, "00" ];
                        //--- For all inputs except the current one, set nSequence to 0
                        var current_sequence = txcopy[ `input_${input_num}` ].sequence;
                        var i; for ( i=0; i<original.number_of_inputs[ 0 ]; i++ ) {
                            if ( !txcopy.hasOwnProperty( `input_${i}` ) ) continue;
                            txcopy[ `input_${i}` ].sequence = "00000000";
                        }
                        txcopy[ `input_${input_num}` ].sequence = current_sequence;
                    }
                    //If the SIGHASH_SINGLE flag is set, apply the following additional modifications
                    var sighash_single_is_set = false;
                    if ( sigflag === "03" || sigflag === "83" ) {
                        sighash_single_is_set = true;
                        //--- If the current input number is greater than the number of outputs, the resulting digest is "01" + "0".repeat( 62 );
                        if ( input_num >= bitcoinjs.Transaction.fromHex( txhex ).outs.length ) return "01" + "0".repeat( 62 );
                        //--- Otherwise, for every output index j, where j does not equal the current output number, set amount to 0xffffffffffffffff (8-byte little-endian, interpreted as -1), and set scriptPubKey to empty (length 0),
                        var i; for ( i=0; i<txcopy.num_of_outputs[ 0 ]; i++ ) {
                            if ( i !== input_num ) {
                                txcopy[ `output_${i}` ].value = "ffffffffffffffff";
                                txcopy[ `output_${i}` ].length_of_scriptPubKey = [ 0, "00" ];
                                txcopy[ `output_${i}` ].scriptPubKey = "";
                            }
                        }
                        //--- ...and set the number of outputs to the current input number plus 1...
                        var i; for ( i=0; i<txcopy.num_of_outputs[ 0 ]; i++ ) {
                            if ( i > input_num + 1 ) delete txcopy[ `output_${i}` ];
                        }
                        var num_of_outputs_as_hex = ( input_num + 1 ).toString( 16 );
                        if ( num_of_outputs_as_hex.length % 2 ) num_of_outputs_as_hex = "0" + num_of_outputs_as_hex;
                        txcopy.num_of_outputs = [ input_num + 1, num_of_outputs_as_hex ];
                        //--- ...and, for all inputs except the current one, set nSequence to 0
                        var current_sequence = txcopy[ `input_${input_num}` ].sequence;
                        var i; for ( i=0; i<original.number_of_inputs[ 0 ]; i++ ) {
                            if ( !txcopy.hasOwnProperty( `input_${i}` ) ) continue;
                            txcopy[ `input_${i}` ].sequence = "00000000";
                        }
                        txcopy[ `input_${input_num}` ].sequence = current_sequence;
                    }
                    //Now it is time to serlialize the preimage, so create an empty string
                    var preimage = "";
                    var parsed_tx = txcopy;
                    //Append the 4 byte nVersion (little-endian)
                    preimage += parsed_tx.version;
                    //Append a VarInt (number of inputs)
                    preimage += parsed_tx.number_of_inputs[ 1 ];
                    //For each input:
                    var i; for ( i=0; i<original.number_of_inputs[ 0 ]; i++ ) {
                        if ( anyone_can_pay_is_set && i !== input_num ) continue;
                        //--- Append a 32 byte prevout hash
                        preimage += parsed_tx[ `input_${i}` ].txid;
                        //--- Append a 4 byte prevout index (little-endian)
                        preimage += parsed_tx[ `input_${i}` ].vout;
                        //--- Append a VarInt (scriptSig length)
                        preimage += parsed_tx[ `input_${i}` ].length_of_scriptsig[ 1 ];
                        //--- Append this input's scriptSig bytes
                        preimage += parsed_tx[ `input_${i}` ].scriptsig;
                        //--- Append a 4 byte nSequence (little-endian)
                        preimage += parsed_tx[ `input_${i}` ].sequence;
                    }
                    //Append the VarInt (number of outputs)
                    preimage += parsed_tx.num_of_outputs[ 1 ];
                    //For each output:
                    var i; for ( i=0; i<original.num_of_outputs[ 0 ]; i++ ) {
                        if ( sighash_single_is_set && i > input_num ) continue;
                        //--- Append an 8 byte amount (little-endian)
                        preimage += parsed_tx[ `output_${i}` ].value;
                        //--- Append a VarInt (scriptPubKey length)
                        preimage += parsed_tx[ `output_${i}` ].length_of_scriptPubKey[ 1 ];
                        //--- Append this output's scriptPubKey bytes
                        preimage += parsed_tx[ `output_${i}` ].scriptPubKey;
                    }
                    //Append the transaction's 4 byte nLockTime (little-endian)
                    preimage += parsed_tx.locktime;
                    //Append the 4 byte sigflag (little-endian)
                    preimage += sigflag + "000000";
                    var sighash = bitcoinjs.crypto.hash256( Buffer.from( preimage, "hex" ) );
                    return sighash.toString( "hex" );
                },
                getLegacyAddress: ( network ) => {
                    var privkey = bitcoinjs.ECPair.makeRandom().__D;
                    var keypair = bitcoinjs.ECPair.fromPrivateKey( privkey );
                    var result = bitcoinjs.crypto.hash160( keypair.publicKey ).toString( "hex" );
                    result = Buffer.from( "76a914" + result + "88ac", "hex" );
                    var address_data = bitcoinjs.payments.p2pkh({ output: result, network: bitcoinjs.networks[ network ] });
                    var address = address_data.address;
                    return [ address, keypair ];
                },
                prepareRestriction: ( network, extra_pubkey, use_gtx ) => {
                    //for an ftx restriction we expect the stack to contain one element, namely, the signature 300602010102010183, which we duplicate, hash, and compare its hash to 32a8efa32f198f21b58d98919a25b0cbcb428d49; if this commitment is satisfied, we know the user provided the right signature, because that's the hash of the above-mentioned signature. However, the original signature was consumed by the hash function, so to check the signature's validity, we check its duplicate that we made in the first step, and check it against a pubkey which we know that signature validates for if and only if the sighash is 0x0100...0000 -- meaning there is no output at this index. The required pubkey (0378...83df) was generated using public key recovery to find out what public key that signature validates for when the message (i.e. the sighash) is 0x0100...0000.
                    var restriction_script = [ "OP_DUP", "OP_RIPEMD160", "32a8efa32f198f21b58d98919a25b0cbcb428d49", "OP_EQUALVERIFY", "03784b6ebe47edcb0b81092d016c054a4375f9d0b73ca68afdf6c97614c83b83df", "OP_CHECKSIG" ];
                    //for a gtx restriction we expect the stack to contain two elements: a public key generated by the user in a manner to be described shortly followed by the signature 300602010102010183. As before, we duplicate the signature and check it against a hash to ensure it is the one we expect. However, we cannot simply check the signature's validity and ensure it's false, because bitcoin's standard mempool policy rules do not allow invalid signatures to be anything but an empty string, and our signature is not that. So, instead, we check the signature against the public key supplied by the user. But currently it is at the back of the stack, with the duplicate of the signature in front of it, so we run OP_SWAP to put them in the right order. Next we duplicate the user's public key and push the duplicate to the altstack, for use later. Then we run OP_CHECKSIGVERIFY, forcing the signature to validate. How does the user get a public key that the signature validates for? The same way we did: by using public key recovery to find out what public key the signature validates for when the message is the sighash for this input. Having ascertained that the signature -- which uses sighash_single | acp -- is valid, we now know one of two things is true: either there is an output at this index -- which is what we want, per the terms of the gtx restriction -- or the sighash for this input is 0x0100...0000. To eliminate the second possiblity, we bring back the duplicate of the user's pubkey from the altstack, compare it with the public key we know represents the sighash 0x0100...0000, and ensure they are not the same (using OP_EQUAL OP_NOT). If they ARE the same, then the user's public key was the one representing the sighash 0x0100...0000, meaning there was no output at this index. That is not what we want, BUT, since their public key matched the one we compared it to, the only item left on the stack is OP_FALSE, so the script is invalid. If, by contrast, the public keys are NOT the same, then the user's public key was NOT the one representing the sighash 0x0100...0000, meaning there IS an output at this index. That is what we want, and since their public key did NOT match the one we compared it to, the only item left on the stack is OP_TRUE, so the script is valid.
                    if ( use_gtx ) restriction_script = [ "OP_DUP", "OP_RIPEMD160", "32a8efa32f198f21b58d98919a25b0cbcb428d49", "OP_EQUALVERIFY", "OP_SWAP", "OP_DUP", "OP_TOALTSTACK", "OP_CHECKSIGVERIFY", "OP_FROMALTSTACK", "03784b6ebe47edcb0b81092d016c054a4375f9d0b73ca68afdf6c97614c83b83df", "OP_EQUAL", "OP_NOT" ];
                    if ( extra_pubkey ) restriction_script.unshift( extra_pubkey, "OP_CHECKSIGVERIFY" );
                    var script = bitcoinjs.script.fromASM( restriction_script.join( " " ) );
                    var scripthash = bitcoinjs.crypto.hash160( script ).toHex();
                    var restriction_address = bitcoinjs.address.fromOutputScript( Buffer.from( "a914" + scripthash + "87", "hex" ), bitcoinjs.networks[ network ] );
                    return [ restriction_address, restriction_script ];
                },
                prepareTx: ( network, inputs, outputs ) => {
                    var psbt = new bitcoinjs.Psbt({ network: bitcoinjs.networks[ network ] });
                    inputs.forEach( input => {
                        psbt.addInput({
                            hash: input.txid,
                            index: input.vout,
                        });
                    });
                    outputs.forEach( output => {
                        if ( output.hasOwnProperty( "address" ) ) {
                            psbt.addOutput({
                                address: output.address,
                                value: output.value,
                            });
                        } else {
                            psbt.addOutput({
                                script: output.script,
                                value: output.value,
                            });
                        }
                    });
                    return psbt.data.globalMap.unsignedTx.toBuffer().toString( "hex" );
                },
                demoFTXRestriction: async network => {
                    cleanup_crew.in_progress = "ftx";
                    //Display initial instructions
                    $( '.instructions' ).innerHTML = `
                        <p>In this demo, we will create a basic restriction called an FTX restriction, which stands for "Fewer Than X."</p>
                        <p>The restriction will consist of an anyone_can_spend bitcoin address with one limitation: its script will inspect the number of outputs and inputs in any transaction that tries to spend money that enters that address, and the script will fail unless the number of outputs is fewer than the number of inputs.</p>
                        <p>Click ok when you are ready.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "ftx" ) return;

                    //Prepare ftx restriction
                    var [ restriction_address, restriction_script ] = cleanup_crew.prepareRestriction( network );
                    var restriction_scriptsig = "09300602010102010183";
                    var final_redeem_script = bitcoinjs.script.fromASM( restriction_script.join( " " ) ).toHex();
                    var final_scriptsig = restriction_scriptsig + bitcoinjs.script.fromASM( final_redeem_script ).toHex();

                    //Display the restriction address
                    $( '.instructions' ).innerHTML = `
                        <p>Here is the restriction address:</p>
                        <p>${restriction_address}</p>
                        <p>It is an anyone_can_spend address whose script contains an FTX restriction requiring the output count to be "fewer than" a certain number, namely, the input count. To prove that the script enforces that restriction, let us fund it and try to spend the money in a transaction *without* fewer outputs than inputs, just to see it fail, i.e. just to see the script enforce the restriction.</p>
                        <p>Fund the address with 10k sats on ${network} and click ok when you are done.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "ftx" ) return;

                    //Get the funding transaction data
                    var restriction_funding_txhex = prompt( `enter the hex of the funding transaction` );
                    var tx = bitcoinjs.Transaction.fromHex( restriction_funding_txhex );
                    var restriction_txinfo = {
                        txid: tx.getId(),
                    }
                    tx.outs.forEach( ( output, index ) => {
                        var calculated_address = bitcoinjs.address.fromOutputScript( output.script, bitcoinjs.networks[ network ] );
                        if ( calculated_address !== restriction_address ) return;
                        restriction_txinfo.vout = index;
                        restriction_txinfo.amnt = output.value;
                    });

                    //Get a destination address
                    var destino = prompt( `Enter an address where you want the restriction-encumbered sats to go\n\nIf you don't have one handy, a test address has been provided`, 'n3qUi7LfcVyXaZQULJxnVFAsmpWKedpC65' );

                    //Prepare an invalid transaction
                    var inputs = [{
                        txid: restriction_txinfo.txid,
                        vout: restriction_txinfo.vout,
                    }];
                    var outputs = [{
                        address: destino,
                        value: restriction_txinfo.amnt - 500,
                    }];
                    var invalid_txhex = cleanup_crew.prepareTx( network, inputs, outputs );
                    var invalid_tx = bitcoinjs.Transaction.fromHex( invalid_txhex );

                    //Add the restriction's scriptsig
                    var invalid_scriptsig = final_scriptsig;
                    invalid_tx.ins[ 0 ].script = Buffer.from( invalid_scriptsig, "hex" );

                    //Display the now-signed invalid transaction
                    $( '.instructions' ).innerHTML = `
                        <p>Try (and fail) to broadcast this transaction, which has 1 input and 1 output. It *would* be valid if not for the restriction in the redeem script, which requires *fewer* outputs than inputs.</p>
                        <p>${invalid_tx.toHex()}</p>
                        <p>Broadcast the transaction on ${network} and click ok when it inevitably fails with an error.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "ftx" ) return;

                    //Create a legacy address
                    var [ address, keypair ] = cleanup_crew.getLegacyAddress( network );
                    var pubkey = keypair.publicKey.toString( "hex" );

                    //Display instructions
                    $( '.instructions' ).innerHTML = `
                        <p>Now we will create a *valid* spending transaction, by adding one extra input, so that the transaction has fewer outputs than inputs, thus satisfying the restriction</p>
                        <p>Here is a "normal" bitcoin address -- send it 10k sats on ${network} (this will become a second input to our transaction, thus making it valid) and click ok when you are done.</p>
                        <p>${address}</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "ftx" ) return;

                    //Get the funding transaction data
                    var normal_funding_txhex = prompt( `enter the hex of the second funding transaction (i.e. the one you just created` );
                    var tx = bitcoinjs.Transaction.fromHex( normal_funding_txhex );
                    var normal_txinfo = {
                        txid: tx.getId(),
                    }
                    tx.outs.forEach( ( output, index ) => {
                        var calculated_address = bitcoinjs.address.fromOutputScript( output.script, bitcoinjs.networks[ network ] );
                        if ( calculated_address !== address ) return;
                        normal_txinfo.vout = index;
                        normal_txinfo.amnt = output.value;
                    });

                    //Send money to that address on regtest
                    var txid0 = normal_txinfo.txid;
                    var vout0 = normal_txinfo.vout;
                    var amnt0 = normal_txinfo.amnt;
                    var thex0 = normal_funding_txhex;

                    //Prepare the restriction's funding info
                    var txid1 = restriction_txinfo.txid;
                    var vout1 = restriction_txinfo.vout;
                    var amnt1 = restriction_txinfo.amnt;
                    var thex1 = restriction_funding_txhex;

                    //Create unsigned restriction tx
                    var inputs = [{
                        txid: txid0,
                        vout: vout0,
                    },{
                        txid: txid1,
                        vout: vout1,
                    }];
                    var outputs = [{
                        address: destino,
                        value: amnt0 + amnt1 - 500,
                    }];
                    var txhex = cleanup_crew.prepareTx( network, inputs, outputs );
                    var tx = bitcoinjs.Transaction.fromHex( txhex );

                    //Sign the first input
                    var prev_tx = thex0;
                    var input_num = 0;
                    var sigflag = "01";
                    var sighash0 = cleanup_crew.getLegacySighash( txhex, prev_tx, input_num, sigflag );
                    var sig0 = keypair.sign( Buffer.from( sighash0, "hex" ), true );
                    var sigflag0 = 1;
                    sig0 = bitcoinjs.script.signature.encode( sig0, sigflag0 ).toString( "hex" );

                    //Add the first input's scriptsig
                    var scriptsig0 = ( sig0.length / 2 ).toString( 16 ) + sig0 + "21" + pubkey;
                    tx.ins[ 0 ].script = Buffer.from( scriptsig0, "hex" );

                    //Add the restriction's scriptsig
                    var scriptsig1 = final_scriptsig;
                    tx.ins[ 1 ].script = Buffer.from( scriptsig1, "hex" );

                    //Display the now-signed transaction
                    $( '.instructions' ).innerHTML = `
                        <p>Broadcast this transaction:</p>
                        <p>${tx.toHex()}</p>
                        <p>Voila! You created a bitcoin address that enforced a basic FTX restriction on bitcoin</p>
                    `;
                    window.scrollTo( 0, 0 );
                    cleanup_crew.in_progress = null;
                },
                demoGTXRestriction: async network => {
                    cleanup_crew.in_progress = "gtx";
                    //Display initial instructions
                    $( '.instructions' ).innerHTML = `
                        <p>In this demo, we will create a restriction called a GTX restriction, which stands for "Greater Than X."</p>
                        <p>The restriction will consist of an anyone_can_spend bitcoin address with one limitation: its script will inspect whether the input being spent has an output at the same index number, and fail if not. This effectively requires the number of outputs to be "greater than" a certain number, namely, the index number of the input containing the restriction, minus one.</p>
                        <p>Click ok when you are ready.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "gtx" ) return;

                    //Prepare gtx restriction
                    var extra_pubkey = null;
                    var use_gtx = true;
                    var [ restriction_address, restriction_script ] = cleanup_crew.prepareRestriction( network, extra_pubkey, use_gtx );

                    //Display the restriction address
                    $( '.instructions' ).innerHTML = `
                        <p>Here is the restriction address:</p>
                        <p>${restriction_address}</p>
                        <p>It is an anyone_can_spend address whose script contains a GTX restriction requiring the output count to be "greater than" a certain number, namely, the input count minus one. To prove that the script enforces that restriction, let us fund it and try to spend the money in a transaction whose output count is *not* greater than that number, just to see it fail, i.e. just to see the script enforce the restriction.</p>
                        <p>Fund the address with 10k sats on ${network} and click ok when you are done.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "gtx" ) return;

                    //Get the funding transaction data
                    var restriction_funding_txhex = prompt( `enter the hex of the funding transaction` );
                    var tx = bitcoinjs.Transaction.fromHex( restriction_funding_txhex );
                    var restriction_txinfo = {
                        txid: tx.getId(),
                    }
                    tx.outs.forEach( ( output, index ) => {
                        var calculated_address = bitcoinjs.address.fromOutputScript( output.script, bitcoinjs.networks[ network ] );
                        if ( calculated_address !== restriction_address ) return;
                        restriction_txinfo.vout = index;
                        restriction_txinfo.amnt = output.value;
                    });

                    //Get a destination address
                    var destino = prompt( `Enter an address where you want the restriction-encumbered sats to go\n\nIf you don't have one handy, a test address has been provided`, 'n3qUi7LfcVyXaZQULJxnVFAsmpWKedpC65' );

                    //Create a legacy address
                    var [ address, keypair ] = cleanup_crew.getLegacyAddress( network );
                    var pubkey = keypair.publicKey.toString( "hex" );

                    //Display the normal address
                    $( '.instructions' ).innerHTML = `
                        <p>Now we have to create an extra input</p>
                        <p>Right now we can create a transaction with 1 input (the address you funded a couple steps ago) and one output (the address you entered one step ago). But such a transaction *would* satisfy the restriction: the restriction would be on input 1, thus requiring an output count greater than 1 minus 1, i.e. an output count greater than 0, which is satisfied by the fact that there is a destination address. To "fix" this (and ensure the restriction is *not* satisfied, so we can see the transaction fail), you must now fund a *normal* bitcoin address. Then we will add it as a second input to our transaction, and place the restriction on input 2 instead of input 1. That will require the transaction to have 2 outputs instead of 1. But there will only be 1 output this time around, so it will fail, thus proving that the restriction is enforced.</p>
                        <p>Here is the "normal address":</p>
                        <p>${address}</p>
                        <p>Fund the address with 10k sats on ${network} and click ok when you are done.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "gtx" ) return;

                    //Get the funding transaction data
                    var normal_funding_txhex = prompt( `enter the hex of the second funding transaction (i.e. the one you just created` );
                    var tx = bitcoinjs.Transaction.fromHex( normal_funding_txhex );
                    var normal_txinfo = {
                        txid: tx.getId(),
                    }
                    tx.outs.forEach( ( output, index ) => {
                        var calculated_address = bitcoinjs.address.fromOutputScript( output.script, bitcoinjs.networks[ network ] );
                        if ( calculated_address !== address ) return;
                        normal_txinfo.vout = index;
                        normal_txinfo.amnt = output.value;
                    });

                    //Prepare a valid transaction
                    var inputs = [{
                        txid: normal_txinfo.txid,
                        vout: normal_txinfo.vout,
                    },{
                        txid: restriction_txinfo.txid,
                        vout: restriction_txinfo.vout,
                    }];
                    var outputs = [{
                        address: destino,
                        value: normal_txinfo.amnt + restriction_txinfo.amnt - 500,
                    },{
                        script: bitcoinjs.script.fromASM( 'OP_RETURN' ),
                        value: 0,
                    }];
                    var txhex = cleanup_crew.prepareTx( network, inputs, outputs );
                    var tx = bitcoinjs.Transaction.fromHex( txhex );

                    //Prepare an invalid transaction
                    outputs.pop();
                    var invalid_txhex = cleanup_crew.prepareTx( network, inputs, outputs );
                    var invalid_tx = bitcoinjs.Transaction.fromHex( invalid_txhex );

                    //Sign the first input of the invalid tx
                    var prev_tx = normal_funding_txhex;
                    var input_num = 0;
                    var sigflag = "83";
                    var sighash0 = cleanup_crew.getLegacySighash( invalid_txhex, prev_tx, input_num, sigflag );
                    var sig0 = keypair.sign( Buffer.from( sighash0, "hex" ), true );
                    var sigflag0 = 3 | 128;
                    sig0 = bitcoinjs.script.signature.encode( sig0, sigflag0 ).toString( "hex" );

                    //Add the first input's scriptsig to the invalid tx
                    var scriptsig0 = ( sig0.length / 2 ).toString( 16 ) + sig0 + "21" + pubkey;
                    invalid_tx.ins[ 0 ].script = Buffer.from( scriptsig0, "hex" );

                    //Add the restriction's scriptsig to the invalid tx
                    var prev_tx = restriction_funding_txhex;
                    var input_num = 1;
                    var final_redeem_script = bitcoinjs.script.fromASM( restriction_script.join( " " ) ).toHex();
                    var sighash1 = cleanup_crew.getLegacySighash( invalid_txhex, prev_tx, input_num, sigflag, final_redeem_script );
                    var recovered_pubkey = nobleSecp256k1.recoverPublicKey( sighash1, "3006020101020101", 1 );
                    recovered_pubkey = nobleSecp256k1.Point.fromHex( recovered_pubkey ).toHex( true );
                    var restriction_scriptsig = `21${recovered_pubkey}09300602010102010183`;
                    var final_scriptsig = restriction_scriptsig + bitcoinjs.script.fromASM( final_redeem_script ).toHex();
                    var invalid_scriptsig = final_scriptsig;
                    invalid_tx.ins[ 1 ].script = Buffer.from( invalid_scriptsig, "hex" );

                    //Display the now-signed invalid transaction
                    $( '.instructions' ).innerHTML = `
                        <p>Try (and fail) to broadcast this transaction, which has 2 inputs and 1 output. It *would* be valid if not for the restriction in the redeem script, which requires an output count *greater than* the index of the input with the restriction minus 1 -- and, as we placed the restriction at index 2, in its current position, the transaction requires an output count greater than 1, which it does not have.</p>
                        <p>${invalid_tx.toHex()}</p>
                        <p>Broadcast the transaction on ${network} and click ok when it inevitably fails with an error.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "gtx" ) return;

                    //Display information about the next step
                    $( '.instructions' ).innerHTML = `
                        <p>Now we will create a valid transaction</p>
                        <p>The only thing we will do is slightly modify our previous transaction: we will add one extra output, which is an op_return with 0 value. That will satisfy the restriction by making the number of outputs greater than 1, which is what the previous transaction required (and hence the new one too).</p>
                        <p>Click ok to continue.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "gtx" ) return;

                    //Sign the first input of the valid tx (its sighash is different from the invalid tx's sighash due to having an extra output -- this is true even though it uses sighash_single, because sighash_single commits to the total output *count* even though it only commits to one actual *output* -- so by adding an extra output, we changed what it commits to, and thus the sighash changed)
                    var prev_tx = normal_funding_txhex;
                    var input_num = 0;
                    var sigflag = "83";
                    var sighash0 = cleanup_crew.getLegacySighash( txhex, prev_tx, input_num, sigflag );
                    var sig0 = keypair.sign( Buffer.from( sighash0, "hex" ), true );
                    var sigflag0 = 3 | 128;
                    sig0 = bitcoinjs.script.signature.encode( sig0, sigflag0 ).toString( "hex" );

                    //Add the first input's scriptsig to the valid tx
                    var scriptsig0 = ( sig0.length / 2 ).toString( 16 ) + sig0 + "21" + pubkey;
                    tx.ins[ 0 ].script = Buffer.from( scriptsig0, "hex" );

                    //Add the restriction's scriptsig to the invalid tx
                    var prev_tx = restriction_funding_txhex;
                    var input_num = 1;
                    var sighash1 = cleanup_crew.getLegacySighash( txhex, prev_tx, input_num, sigflag, final_redeem_script );
                    var recovered_pubkey = nobleSecp256k1.recoverPublicKey( sighash1, "3006020101020101", 1 );
                    recovered_pubkey = nobleSecp256k1.Point.fromHex( recovered_pubkey ).toHex( true );
                    var restriction_scriptsig = `21${recovered_pubkey}09300602010102010183`;
                    var final_scriptsig = restriction_scriptsig + bitcoinjs.script.fromASM( final_redeem_script ).toHex();
                    var valid_scriptsig = final_scriptsig;
                    tx.ins[ 1 ].script = Buffer.from( valid_scriptsig, "hex" );

                    //Display the now-signed transaction
                    $( '.instructions' ).innerHTML = `
                        <p>Broadcast this transaction:</p>
                        <p>${tx.toHex()}</p>
                        <p>Voila! You created a bitcoin address that enforced a GTX restriction on bitcoin</p>
                    `;
                    window.scrollTo( 0, 0 );
                    cleanup_crew.in_progress = null;
                },
                demoCleanupRestriction: async network => {
                    cleanup_crew.in_progress = "cleanup";
                    //Display initial instructions
                    $( '.instructions' ).innerHTML = `
                        <p>In this demo, we will create an advanced restriction called a cleanup restriction, designed to automatically pay people who consume many outputs from the utxo set.</p>
                        <p>The restriction will consist of a bitcoin address with two limitations: in any transaction that tries to spend money locked to this address, the number of outputs must be smaller than the number of inputs, and it must have a signature from an extra pubkey too.</p>
                        <p>Then we will publish an anyone_can_pay signature for that extra pubkey that specifies all the outputs, but not the inputs. Specifically, it will require 98 unspendable op_return outputs and 1 spendable "bounty address" that is truly anyone_can_spend. We expect someone to come along and take the bounty for himself or herself.</p>
                        <p>Once we fund the restriction and publish the signature, anyone can take the money from the restriction and use it to fund (and then sweep) the bounty address, but only if their transaction consumes 100+ inputs from the utxo set and creates 1 spendable output (which is the bounty itself).</p>
                        <p>Click ok when you are ready.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "cleanup" ) return;

                    //Prepare the restriction
                    var extra_privkey = bitcoinjs.ECPair.makeRandom().__D;
                    var extra_keypair = bitcoinjs.ECPair.fromPrivateKey( extra_privkey );
                    var extra_pubkey = extra_keypair.publicKey.toString( "hex" );
                    var [ restriction_address, restriction_script ] = cleanup_crew.prepareRestriction( network, extra_pubkey );
                    var restriction_scriptsig = "09300602010102010183";
                    var final_redeem_script = bitcoinjs.script.fromASM( restriction_script.join( " " ) ).toHex();

                    //Display the restriction address
                    $( '.instructions' ).innerHTML = `
                        <p>Here is the restriction address:</p>
                        <p>${restriction_address}</p>
                        <p>It will be an anyone_can_spend address as soon as we publish the anyone_can_pay signature, which we will do after we fund the restriction. The anyone_can_pay signature will require anyone who wants to use it to create 99 outputs -- only 1 of them will end up in the utxo set, the others are op_returns. But users can't simply spend the money by creating the right set of outputs -- the *restriction* requires the number of outputs to be *fewer* than the number of inputs, which means no spend transaction using the ACP signature is valid unless it consumes 100+ inputs. So this restriction will pay people to clean up the utxo set. It's a cleanup restriction.</p>
                        <p>To illustrate how it works, let us fund it and try to spend the money in a transaction with *only one* input, just to see it fail, i.e. just to see the script enforce the restriction.</p>
                        <p>Fund the address with 10k sats on ${network} (this will become a second input to our transaction, thus making it valid) and click ok when you are done. Here is the restriction address again:</p>
                        <p>${restriction_address}</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "cleanup" ) return;

                    //Get the funding transaction data
                    var restriction_funding_txhex = prompt( `enter the hex of the funding transaction` );
                    var tx = bitcoinjs.Transaction.fromHex( restriction_funding_txhex );
                    var restriction_txinfo = {
                        txid: tx.getId(),
                    }
                    tx.outs.forEach( ( output, index ) => {
                        var calculated_address = bitcoinjs.address.fromOutputScript( output.script, bitcoinjs.networks[ network ] );
                        if ( calculated_address !== restriction_address ) return;
                        restriction_txinfo.vout = index;
                        restriction_txinfo.amnt = output.value;
                    });

                    //Prepare an anyone_can_spend address
                    var acs_script = bitcoinjs.script.fromASM( 'OP_TRUE' );
                    var acs_scripthash = bitcoinjs.crypto.hash160( acs_script ).toHex();
                    var acs_address = bitcoinjs.address.fromOutputScript( Buffer.from( "a914" + acs_scripthash + "87", "hex" ), bitcoinjs.networks[ network ] );
                    var acs_scriptsig = "0151";

                    //Prepare a tx with that acs_address as an output plus 99 op_returns, so you can make the ACP sig
                    var inputs = [{
                        txid: restriction_txinfo.txid,
                        vout: restriction_txinfo.vout,
                    }];
                    var required_outputs = [{
                        address: acs_address,
                        value: restriction_txinfo.amnt - 5_000,
                    }];
                    var i; for ( i=0; i<98; i++ ) required_outputs.push({
                        script: bitcoinjs.script.fromASM( 'OP_RETURN' ),
                        value: 0,
                    });
                    var acp_txhex = cleanup_crew.prepareTx( network, inputs, required_outputs );

                    //Make the ACP sig
                    var prev_tx = restriction_funding_txhex;
                    var input_num = 0;
                    var sigflag = "81";
                    var redeem_script = final_redeem_script;
                    var acp_sighash = cleanup_crew.getLegacySighash( acp_txhex, prev_tx, input_num, sigflag, redeem_script );
                    var acp_sig = extra_keypair.sign( Buffer.from( acp_sighash, "hex" ), true );
                    var acp_sigflag = 1 | 128;
                    acp_sig = bitcoinjs.script.signature.encode( acp_sig, acp_sigflag ).toString( "hex" );
                    var length_of_acp_sig = acp_sig.length / 2;
                    var length_of_acp_sig_in_hex = length_of_acp_sig.toString( 16 );
                    if ( length_of_acp_sig_in_hex.length % 2 ) length_of_acp_sig_in_hex = "0" + length_of_acp_sig_in_hex;

                    //Create a legacy address for funding 99 outputs for user later
                    var [ ninety_nine_output_maker, nn_keypair ] = cleanup_crew.getLegacyAddress( network );
                    var nn_pubkey = nn_keypair.publicKey.toString( "hex" );

                    //Display instructions about creating 99 utxos
                    $( '.instructions' ).innerHTML = `
                        <p>The restriction will require us to consume 100+ utxos as inputs. However, 100 utxos do not necessarily exist yet on your regtest network. In fact, this app only knows 1 utxo that definitely exists: the one locked to the restriction address. So now we will make 99 more, so that a transaction we'll create later can consume them.</p>
                        <p>Fund the address below with 56,785 sats on ${network}. That is 99 * 540 + 3,325. The 99 is for the 99 utxos, each of which will be funded with 540 sats, which is the dust limit for the types of addresses we're going to create. The extra 3,325 will pay for mining fees.</p>
                        <p>${ninety_nine_output_maker}</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "cleanup" ) return;

                    //Get the funding transaction data
                    var nn_funding_txhex = prompt( `enter the hex of the funding transaction` );
                    var tx = bitcoinjs.Transaction.fromHex( nn_funding_txhex );
                    var nn_txinfo = {
                        txid: tx.getId(),
                    }
                    tx.outs.forEach( ( output, index ) => {
                        var calculated_address = bitcoinjs.address.fromOutputScript( output.script, bitcoinjs.networks[ network ] );
                        if ( calculated_address !== ninety_nine_output_maker ) return;
                        nn_txinfo.vout = index;
                        nn_txinfo.amnt = output.value;
                    });

                    //Prepare a tx that creates 99 outputs
                    var inputs = [{
                        txid: nn_txinfo.txid,
                        vout: nn_txinfo.vout,
                    }];
                    var outputs = [];
                    var i; for ( i=0; i<99; i++ ) outputs.push({
                        address: acs_address,
                        value: 540,
                    });
                    var nn_txhex = cleanup_crew.prepareTx( network, inputs, outputs );
                    var nn_tx = bitcoinjs.Transaction.fromHex( nn_txhex );

                    //Sign the first input
                    var prev_tx = nn_funding_txhex;
                    var input_num = 0;
                    var sigflag = "01";
                    var nn_sighash = cleanup_crew.getLegacySighash( nn_txhex, prev_tx, input_num, sigflag );
                    var nn_sig = nn_keypair.sign( Buffer.from( nn_sighash, "hex" ), true );
                    var nn_sigflag = 1;
                    nn_sig = bitcoinjs.script.signature.encode( nn_sig, nn_sigflag ).toString( "hex" );

                    //Add the first input's scriptsig
                    var nn_scriptsig = ( nn_sig.length / 2 ).toString( 16 ) + nn_sig + "21" + nn_pubkey;
                    nn_tx.ins[ 0 ].script = Buffer.from( nn_scriptsig, "hex" );

                    //Get the txid for use later
                    var nn_txid = nn_tx.getId();

                    //Display the now-signed transaction
                    $( '.instructions' ).innerHTML = `
                        <p>Broadcast this transaction:</p>
                        <p>${nn_tx.toHex()}</p>
                        <p>Now there are 100 outputs for us to consume later -- 99 that we just created plus the 1 in the restriction address. Our next step is to create a transaction that tries to spend the restriction-encumbered sats, but it will only consume 99 total utxos, not the 100+ required by the restriction. This transaction will be invalid, but we will try it anyway, just to see it fail, i.e. just to see the script enforce the restriction.</p>
                        <p>Click ok to continue.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "cleanup" ) return;

                    //Get a destination address
                    var destino = prompt( `Enter an address where you want the restriction-encumbered sats to go\n\nIf you don't have one handy, a test address has been provided`, 'n3qUi7LfcVyXaZQULJxnVFAsmpWKedpC65' );

                    //Prepare an invalid transaction
                    var inputs = [{
                        txid: restriction_txinfo.txid,
                        vout: restriction_txinfo.vout,
                    }];
                    var i; for ( i=98; i>0; i-- ) {
                        inputs.unshift({
                            txid: nn_txid,
                            vout: i,
                        });
                    }
                    var invalid_txhex = cleanup_crew.prepareTx( network, inputs, required_outputs );
                    var invalid_tx = bitcoinjs.Transaction.fromHex( invalid_txhex );

                    //Add the restriction's scriptsig
                    var invalid_scriptsig = restriction_scriptsig + length_of_acp_sig_in_hex + acp_sig + bitcoinjs.script.fromASM( final_redeem_script ).toHex();
                    invalid_tx.ins[ invalid_tx.ins.length - 1 ].script = Buffer.from( invalid_scriptsig, "hex" );

                    //Add a scriptsig for every other input
                    var i; for ( i=0; i<98; i++ ) invalid_tx.ins[ i ].script = Buffer.from( acs_scriptsig, "hex" );

                    //Display the now-signed invalid transaction
                    $( '.instructions' ).innerHTML = `
                        <p>Try (and fail) to broadcast this transaction, which has 99 inputs and 99 outputs. It *would* be valid if not for the restriction in the redeem script, which requires 100+ inputs because the ACP sig requires 99 outputs.</p>
                        <p>${invalid_tx.toHex()}</p>
                        <p>Broadcast the transaction on ${network} and click ok when it inevitably fails with an error.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "cleanup" ) return;

                    //Display instructions
                    $( '.instructions' ).innerHTML = `
                        <p>Now we will create a *valid* spending transaction, by consuming all 100 inputs we've created rather than only 99 of them -- then the transaction will have fewer outputs than inputs, thus satisfying the restriction.</p>
                        <p>Click ok to continue.</p>
                        <p><button class="continue">ok</button></p>
                    `;
                    window.scrollTo( 0, 0 );

                    //Wait til user clicks ok
                    $( '.continue' ).onclick = () => cleanup_crew.waiting = false;
                    await cleanup_crew.wait();
                    if ( cleanup_crew.in_progress !== "cleanup" ) return;

                    //Create unsigned restriction tx
                    inputs.unshift({
                        txid: nn_txid,
                        vout: 0,
                    });
                    var txhex = cleanup_crew.prepareTx( network, inputs, required_outputs );
                    var tx = bitcoinjs.Transaction.fromHex( txhex );

                    //Add the restriction's scriptsig
                    var final_scriptsig = restriction_scriptsig + length_of_acp_sig_in_hex + acp_sig + bitcoinjs.script.fromASM( final_redeem_script ).toHex();
                    tx.ins[ tx.ins.length - 1 ].script = Buffer.from( final_scriptsig, "hex" );

                    //Add a scriptsig for every other input
                    var i; for ( i=0; i<99; i++ ) tx.ins[ i ].script = Buffer.from( acs_scriptsig, "hex" );

                    //Display the now-signed transaction
                    $( '.instructions' ).innerHTML = `
                        <p>Broadcast this transaction:</p>
                        <p>${tx.toHex()}</p>
                        <p>Voila! You created a bitcoin address that enforced a cleanup restriction -- an address that anyone can spend from with its anyone_can_pay signature, but only in a transaction that consumes 100+ inputs and creates only 1 spendable output.</p>
                    `;
                    window.scrollTo( 0, 0 );
                    cleanup_crew.in_progress = null;
                },
            }
        </script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 800px;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
                padding: 0;
            }
            body {
                margin: 3rem 1rem;
                word-wrap: break-word;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            .hidden {
                display: none !important;
            }
            .instructions_div {
                background-color: #cccccc;
                padding: 1rem;
            }
            .instructions_div * {
                font-family: monospace;
            }
            .restriction_button {
                margin: .5rem 0;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
            var hash_arr = window.location.href.substring( window.location.href.indexOf( "#" ) ).split( "#" );
            hash_arr.splice( 0, 1 );
            var $_HASH = {}
            hash_arr.forEach( item => {
                var vals = item.split( "=" );
                $_HASH[ vals[ 0 ] ] = vals[ 1 ];
            });
        </script>
    </head>
    <body>
        <h1>Cleanup Crew</h1>
        <p><button class="restriction_button ftx_restriction">FTX restriction</button> <button class="restriction_button gtx_restriction">GTX restriction</button> <button class="restriction_button cleanup_restriction">Cleanup restriction</button></p>
        <div class="instructions_div">
            <p>Instructions:</p>
            <div class="instructions">
                <p>Pick a restriction to demo -- further instructions will appear here</p>
            </div>
        </div>
        <script>
            $( '.ftx_restriction' ).onclick = async () => {
                var network = cleanup_crew.network;
                cleanup_crew.demoFTXRestriction( network );
            }
            $( '.gtx_restriction' ).onclick = async () => {
                var network = cleanup_crew.network;
                cleanup_crew.demoGTXRestriction( network );
            }
            $( '.cleanup_restriction' ).onclick = async () => {
                var network = cleanup_crew.network;
                cleanup_crew.demoCleanupRestriction( network );
            }
        </script>
    </body>
</html>
